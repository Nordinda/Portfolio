---
import { getLangFromUrl, useTranslations } from "@/i18n/utils";
type tLang = (str: any) => any;
const lang = getLangFromUrl(Astro.url);
const t:tLang = useTranslations(lang);
type Experience = {
date: string;
title: string;
company: string;
description: string;
latest?: boolean;
};
const EXPERIENCE: Experience[] = t('exp');
---
<ol class="relative w-full max-w-7xl px-4 mx-auto">
  {/* Graue Hintergrund-Linie - unauffällig */}
  <div class="absolute left-1/3 transform -translate-x-1/4 w-0.5 h-full bg-gray-800/50"></div>
  
  {/* Animierte Farb-Linie die sich füllt */}
<div 
      id="progress-line" 
      class="absolute left-1/3 -translate-x-1/5 w-0.5 bg-gradient-to-b from-rose-800/80 via-purple-500/40 to-purple-800/80 transition-all duration-500 ease-out"
      style="height: 0%; top: 0;"
      aria-hidden="true"
    />  
  {
    EXPERIENCE.map((experience, index) => (
      <li class="mb-20 flex items-start gap-10">
        {/* Links: Date, Title, Company */}
        <div class="w-3/12 text-right pr-10">
          <time class="text-sm text-gray-500 mb-2 block font-medium">{experience.date}</time>
          <h3 class="text-xl font-bold text-white mb-1">{experience.title}</h3>
          <p class="text-base text-purple-400 font-medium">{experience.company}</p>
        </div>
        
        {/* Mitte: Timeline Dot */}
        <div class="relative flex-shrink-0 z-10">
          <div class={`rounded-full border-2 border-gray-900 transition-all duration-500 timeline-dot ${
            experience.latest 
              ? 'w-4 h-4 bg-purple-500 shadow-[0_0_25px_rgba(168,85,247,1)] ring-4 ring-purple-500/30 animate-pulse' 
              : 'w-2.5 h-2.5 bg-gray-500/80'
          }`}></div>
        </div>
        
        {/* Rechts: Description */}
        <div class="w-8/12 pl-10">
          <p class="text-gray-300 text-base leading-relaxed">{experience.description}</p>
        </div>
      </li>
    ))
  }
</ol>


<script>
  const updateTimeline = () => {
    const timeline = document.querySelector('ol');
    const progressLine = document.getElementById('progress-line');
    const dots = document.querySelectorAll('.timeline-dot');
    const items = document.querySelectorAll('.timeline-item');
    
    if (!timeline || !progressLine) return;
    
    const { top, height } = timeline.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    
    // Calculate scroll progress
    const scrollProgress = Math.max(0, Math.min(1, 
      (windowHeight * 0.6 - top) / (height * 0.9)
    ));
    
    progressLine.style.height = `${scrollProgress * 100}%`;
    
    // Animate dots
    dots.forEach((dot) => {
      const { top: dotTop, height: dotHeight } = dot.getBoundingClientRect();
      const dotMiddle = dotTop + dotHeight / 2;
      
      if (!dot.classList.contains('ring-2')) {
        if (dotMiddle < windowHeight * 0.65) {
          dot.classList.add('!bg-rose-500/70', 'shadow-sm', 'shadow-rose-500/30');
          dot.classList.remove('bg-gray-700/90');
        } else {
          dot.classList.remove('!bg-rose-500/70', 'shadow-sm', 'shadow-rose-500/30');
          dot.classList.add('bg-gray-700/90');
        }
      }
    });
    
    // Fade in timeline items
    items.forEach((item) => {
      const { top: itemTop } = item.getBoundingClientRect();
      if (itemTop < windowHeight * 0.8) {
        item.classList.remove('opacity-0', 'translate-x-8', '-translate-x-8');
        item.classList.add('opacity-100', 'translate-x-0');
      }
    });
  };
  
  // Throttle scroll events for better performance
  let ticking = false;
  const handleScroll = () => {
    if (!ticking) {
      window.requestAnimationFrame(() => {
        updateTimeline();
        ticking = false;
      });
      ticking = true;
    }
  };
  
  window.addEventListener('scroll', handleScroll, { passive: true });
  window.addEventListener('load', updateTimeline);
  
  // Initial update
  updateTimeline();
</script>

<style>
  .timeline-item {
    will-change: transform, opacity;
  }
</style>
